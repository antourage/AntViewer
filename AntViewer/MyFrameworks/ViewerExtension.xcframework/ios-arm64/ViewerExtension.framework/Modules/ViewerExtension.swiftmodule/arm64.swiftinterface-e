// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.1 (swiftlang-1200.0.41 clang-1200.0.32.8)
// swift-module-flags: -target arm64-apple-ios11.3 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name ViewerExtension
import AVFoundation
import AVKit
import AVFoundation.AVPlayerItem
import CoreData
import Foundation
import MediaPlayer
import Swift
import SystemConfiguration
import UIKit
@_exported import ViewerExtension
import os.log
import os
import zlib
@objc public class LatestComment : ObjectiveC.NSObject, Foundation.NSSecureCoding {
  @objc public static var supportsSecureCoding: Swift.Bool {
    @objc get
  }
  public var nickname: Swift.String
  public var text: Swift.String
  public var userID: Swift.String
  public var date: Foundation.Date? {
    get
  }
  @objc public func encode(with coder: Foundation.NSCoder)
  @objc required convenience public init?(coder: Foundation.NSCoder)
  public init(userID: Swift.String, nickname: Swift.String, text: Swift.String, timestamp: Swift.Int?)
  @objc deinit
  @objc override dynamic public init()
}
@_hasMissingDesignatedInitializers public class StreamHandle {
  @objc deinit
}
public protocol PlayerMedia : Swift.CustomStringConvertible {
  var url: Foundation.URL { get }
  var type: ViewerExtension.MediaType { get }
  var assetOptions: [Swift.String : Any]? { get }
  func isLive() -> Swift.Bool
  func getMetadata() -> ViewerExtension.PlayerMediaMetadata?
  func setMetadata(_ metadata: ViewerExtension.PlayerMediaMetadata?)
}
extension PlayerMedia {
  public var description: Swift.String {
    get
  }
}
extension PlayerMedia {
  public func isLive() -> Swift.Bool
}
public protocol PlayerMediaMetadata : Swift.CustomStringConvertible {
  var title: Swift.String? { get }
  var artist: Swift.String? { get }
  var albumTitle: Swift.String? { get }
  var image: Foundation.Data? { get }
  var remoteImageUrl: Foundation.URL? { get }
}
extension PlayerMediaMetadata {
  public var description: Swift.String {
    get
  }
}
public protocol Transport : AnyObject {
  var delegate: ViewerExtension.TransportDelegate? { get set }
  func start(url: Foundation.URL, options: ViewerExtension.HttpConnectionOptions)
  func send(data: Foundation.Data, sendDidComplete: @escaping (Swift.Error?) -> Swift.Void)
  func close()
}
public class ModernAVPlayerMedia : ViewerExtension.PlayerMedia {
  final public let url: Foundation.URL
  final public let type: ViewerExtension.MediaType
  final public let assetOptions: [Swift.String : Any]?
  public init(url: Foundation.URL, type: ViewerExtension.MediaType, metadata: ViewerExtension.ModernAVPlayerMediaMetadata? = nil, assetOptions: [Swift.String : Any]? = nil)
  public func getMetadata() -> ViewerExtension.PlayerMediaMetadata?
  public func setMetadata(_ metadata: ViewerExtension.PlayerMediaMetadata?)
  @objc deinit
}
public enum PlayerError : Swift.Error {
  case loadingFailed
  case playbackStalled
  case bufferingFailed
  public static func == (a: ViewerExtension.PlayerError, b: ViewerExtension.PlayerError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@objc @_inheritsConvenienceInitializers public class StreamCell : UIKit.UICollectionViewCell {
  @objc override dynamic public func layoutSubviews()
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public struct ModernAVPlayerConfiguration : ViewerExtension.PlayerConfiguration {
  public let rateObservingTimeout: Swift.Double
  public let rateObservingTickTime: Swift.Double
  public let preferredTimescale: CoreMedia.CMTimeScale
  public let periodicPlayingTime: CoreMedia.CMTime
  public let audioSessionCategory: AVFoundation.AVAudioSession.Category
  public let reachabilityURLSessionTimeout: Swift.Double
  public let reachabilityNetworkTestingURL: Foundation.URL
  public let reachabilityNetworkTestingTickTime: Swift.Double
  public let reachabilityNetworkTestingIteration: Swift.UInt
  public var useDefaultRemoteCommand: Swift.Bool
  public let allowsExternalPlayback: Swift.Bool
  public let itemLoadedAssetKeys: [Swift.String]
  public init()
}
public protocol PlayerMediaItem : ViewerExtension.PlayerMedia {
  var item: AVFoundation.AVPlayerItem { get }
}
public protocol PlayerCommand {
  func load(media: ViewerExtension.PlayerMedia, autostart: Swift.Bool, position: Swift.Double?)
  func pause()
  func play()
  func seek(position: Swift.Double)
  func stop()
}
extension String {
  public func height(withConstrainedWidth width: CoreGraphics.CGFloat, font: UIKit.UIFont) -> CoreGraphics.CGFloat
}
public struct AntourageAVPlayerConfiguration : ViewerExtension.PlayerConfiguration {
  public let rateObservingTimeout: Swift.Double
  public let rateObservingTickTime: Swift.Double
  public let preferredTimescale: CoreMedia.CMTimeScale
  public let periodicPlayingTime: CoreMedia.CMTime
  public let audioSessionCategory: AVFoundation.AVAudioSession.Category
  public let reachabilityURLSessionTimeout: Swift.Double
  public let reachabilityNetworkTestingURL: Foundation.URL
  public let reachabilityNetworkTestingTickTime: Swift.Double
  public let reachabilityNetworkTestingIteration: Swift.UInt
  public var useDefaultRemoteCommand: Swift.Bool
  public let allowsExternalPlayback: Swift.Bool
  public let itemLoadedAssetKeys: [Swift.String]
  public init()
}
public enum WidgetState {
  case resting
  case vod
  case live
  case loading(player: AVFoundation.AVPlayer)
}
@objc @_inheritsConvenienceInitializers final public class WidgetView : UIKit.UIView {
  @objc override final public func layoutSubviews()
  @objc override final public func didMoveToSuperview()
  @objc override final public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @objc override final public func willMove(toWindow newWindow: UIKit.UIWindow?)
  final public func prepare(for state: ViewerExtension.WidgetState, immediately: Swift.Bool, completion: ((ViewerExtension.WidgetState) -> Swift.Void)?)
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension WidgetView {
  @objc final public var onViewerAppear: ((Foundation.NSDictionary) -> Swift.Void)? {
    @objc get
    @objc set
  }
  @objc final public var onViewerDisappear: ((Foundation.NSDictionary) -> Swift.Void)? {
    @objc get
    @objc set
  }
  @objc final public var widgetPosition: Swift.String {
    @objc get
    @objc set
  }
  @objc final public var widgetMargins: Foundation.NSDictionary {
    @objc get
    @objc set
  }
  @objc final public var widgetLocale: Swift.String {
    @objc get
    @objc set
  }
}
public struct WebSocketEvents {
  public var open: () -> ()
  public var close: (Swift.Int, Swift.String, Swift.Bool) -> ()
  public var error: (Swift.Error) -> ()
  public var message: (Any) -> ()
  public var pong: (Any) -> ()
  public var end: (Swift.Int, Swift.String, Swift.Bool, Swift.Error?) -> ()
}
public enum WebSocketBinaryType : Swift.CustomStringConvertible {
  case uInt8Array
  case nsData
  case uInt8UnsafeBufferPointer
  public var description: Swift.String {
    get
  }
  public static func == (a: ViewerExtension.WebSocketBinaryType, b: ViewerExtension.WebSocketBinaryType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@objc public enum WebSocketReadyState : Swift.Int, Swift.CustomStringConvertible {
  case connecting = 0
  case open = 1
  case closing = 2
  case closed = 3
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public struct WebSocketCompression {
  public var on: Swift.Bool
  public var noContextTakeover: Swift.Bool
  public var maxWindowBits: Swift.Int
}
public struct WebSocketService : Swift.OptionSet {
  public typealias RawValue = Swift.UInt
  public init(rawValue value: Swift.UInt)
  public init(nilLiteral: ())
  public static var allZeros: ViewerExtension.WebSocketService {
    get
  }
  public var rawValue: Swift.UInt {
    get
  }
  public static var None: ViewerExtension.WebSocketService {
    get
  }
  public static var VoIP: ViewerExtension.WebSocketService {
    get
  }
  public static var Video: ViewerExtension.WebSocketService {
    get
  }
  public static var Background: ViewerExtension.WebSocketService {
    get
  }
  public static var Voice: ViewerExtension.WebSocketService {
    get
  }
  public typealias Element = ViewerExtension.WebSocketService
  public typealias ArrayLiteralElement = ViewerExtension.WebSocketService
}
public enum WebSocketError : Swift.Error, Swift.CustomStringConvertible {
  case memory
  case needMoreInput
  case invalidHeader
  case invalidAddress
  case network(Swift.String)
  case libraryError(Swift.String)
  case payloadError(Swift.String)
  case protocolError(Swift.String)
  case invalidResponse(Swift.String)
  case invalidCompressionOptions(Swift.String)
  public var description: Swift.String {
    get
  }
  public var details: Swift.String {
    get
  }
}
@objc public protocol WebSocketDelegate {
  @objc func webSocketOpen()
  @objc func webSocketClose(_ code: Swift.Int, reason: Swift.String, wasClean: Swift.Bool)
  @objc func webSocketError(_ error: Foundation.NSError)
  @objc optional func webSocketMessageText(_ text: Swift.String)
  @objc optional func webSocketMessageData(_ data: Foundation.Data)
  @objc optional func webSocketPong()
  @objc optional func webSocketEnd(_ code: Swift.Int, reason: Swift.String, wasClean: Swift.Bool, error: Foundation.NSError?)
}
@objc @_inheritsConvenienceInitializers @objcMembers open class WebSocket : ObjectiveC.NSObject {
  @objc override dynamic open var hash: Swift.Int {
    @objc get
  }
  @objc override dynamic open func isEqual(_ other: Any?) -> Swift.Bool
  @objc convenience public init(_ url: Swift.String)
  @objc convenience public init(url: Foundation.URL)
  @objc convenience public init(_ url: Swift.String, subProtocols: [Swift.String])
  @objc convenience public init(_ url: Swift.String, subProtocol: Swift.String)
  @objc public init(request: Foundation.URLRequest, subProtocols: [Swift.String] = [])
  @objc convenience override dynamic public init()
  @objc open var url: Swift.String {
    @objc get
  }
  @objc open var subProtocol: Swift.String {
    @objc get
  }
  open var compression: ViewerExtension.WebSocketCompression {
    get
    set
  }
  @objc open var allowSelfSignedSSL: Swift.Bool {
    @objc get
    @objc set
  }
  open var services: ViewerExtension.WebSocketService {
    get
    set
  }
  open var event: ViewerExtension.WebSocketEvents {
    get
    set
  }
  @objc open var eventQueue: Dispatch.DispatchQueue? {
    @objc get
    @objc set
  }
  open var binaryType: ViewerExtension.WebSocketBinaryType {
    get
    set
  }
  @objc open var readyState: ViewerExtension.WebSocketReadyState {
    @objc get
  }
  @objc open func open(_ url: Swift.String)
  @objc open func open(nsurl url: Foundation.URL)
  @objc open func open(_ url: Swift.String, subProtocols: [Swift.String])
  @objc open func open(_ url: Swift.String, subProtocol: Swift.String)
  @objc open func open(request: Foundation.URLRequest, subProtocols: [Swift.String] = [])
  @objc open func open()
  @objc open func close(_ code: Swift.Int = 1000, reason: Swift.String = "Normal Closure")
  @objc open func send(_ message: Any)
  @objc open func ping(_ message: Any)
  @objc open func ping()
  @objc deinit
}
public func == (lhs: ViewerExtension.WebSocket, rhs: ViewerExtension.WebSocket) -> Swift.Bool
extension WebSocket {
  @objc dynamic public var delegate: ViewerExtension.WebSocketDelegate? {
    @objc get
    @objc set
  }
  @objc dynamic public func send(text: Swift.String)
  @objc dynamic public func send(data: Foundation.Data)
}
extension Int {
  public func durationString(full: Swift.Bool = false) -> Swift.String
  public func formatUsingAbbrevation() -> Swift.String
}
extension String {
  public func duration() -> Swift.Int
}
public class ModernAVPlayerRemoteCommandFactory {
  public var defaultCommands: [ViewerExtension.ModernAVPlayerRemoteCommand] {
    get
  }
  public init(player: ViewerExtension.ModernAVPlayerExposable, commandCenter: MediaPlayer.MPRemoteCommandCenter = MPRemoteCommandCenter.shared())
  public var playCommand: ViewerExtension.ModernAVPlayerRemoteCommand {
    get
    set
  }
  public var togglePlayPauseCommand: ViewerExtension.ModernAVPlayerRemoteCommand {
    get
    set
  }
  public var pauseCommand: ViewerExtension.ModernAVPlayerRemoteCommand {
    get
    set
  }
  public var stopCommand: ViewerExtension.ModernAVPlayerRemoteCommand {
    get
    set
  }
  public var changePositionCommand: ViewerExtension.ModernAVPlayerRemoteCommand {
    get
    set
  }
  public func skipBackwardCommand(preferredIntervals: [Foundation.NSNumber] = [10]) -> ViewerExtension.ModernAVPlayerRemoteCommand
  public func skipForwardCommand(preferredIntervals: [Foundation.NSNumber] = [10]) -> ViewerExtension.ModernAVPlayerRemoteCommand
  @objc deinit
}
public class ModernAVPlayerMediaItem : ViewerExtension.PlayerMediaItem {
  final public let item: AVFoundation.AVPlayerItem
  final public let url: Foundation.URL
  final public let type: ViewerExtension.MediaType
  final public let assetOptions: [Swift.String : Any]?
  public init?(item: AVFoundation.AVPlayerItem, type: ViewerExtension.MediaType, metadata: ViewerExtension.ModernAVPlayerMediaMetadata? = nil, assetOptions: [Swift.String : Any]? = nil)
  public func getMetadata() -> ViewerExtension.PlayerMediaMetadata?
  public func setMetadata(_ metadata: ViewerExtension.PlayerMediaMetadata?)
  @objc deinit
}
extension OSLog {
  public static let antNetworking: os.OSLog
  public static let antButton: os.OSLog
}
public struct NotificationResponse : Swift.Codable {
  public let success: Swift.Bool
  public let topic: Swift.String
  public let error: Swift.String?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers public class WebsocketsTransport : ViewerExtension.Transport {
  weak public var delegate: ViewerExtension.TransportDelegate?
  public func start(url: Foundation.URL, options: ViewerExtension.HttpConnectionOptions)
  public func send(data: Foundation.Data, sendDidComplete: (Swift.Error?) -> Swift.Void)
  public func close()
  @objc deinit
}
public struct RetryContext {
  public let failedAttemptsCount: Swift.Int
  public let reconnectStartTime: Foundation.Date
  public let error: Swift.Error
}
public protocol ReconnectPolicy {
  func nextAttemptInterval(retryContext: ViewerExtension.RetryContext) -> Dispatch.DispatchTimeInterval
}
public class DefaultReconnectPolicy : ViewerExtension.ReconnectPolicy {
  public init(retryIntervals: [Dispatch.DispatchTimeInterval] = [.milliseconds(0), .seconds(2), .seconds(10), .seconds(30)])
  public func nextAttemptInterval(retryContext: ViewerExtension.RetryContext) -> Dispatch.DispatchTimeInterval
  @objc deinit
}
public protocol HostChangeable : AnyObject {
}
extension HostChangeable where Self : UIKit.UIViewController {
  public func presentChangeHostAlert()
}
extension MessageMO {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<ViewerExtension.MessageMO>
  @objc @NSManaged dynamic public var nickname: Swift.String {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var text: Swift.String {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var timestamp: Swift.Int64 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var userId: Swift.String {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var key: Swift.String {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var content: ViewerExtension.VideoContentMO? {
    @objc get
    @objc set
  }
}
public class HubConnection {
  weak public var delegate: ViewerExtension.HubConnectionDelegate?
  public var connectionId: Swift.String? {
    get
  }
  public init(connection: ViewerExtension.Connection, hubProtocol: ViewerExtension.HubProtocol, logger: ViewerExtension.Logger = NullLogger())
  @objc deinit
  public func start()
  public func stop()
  public func on(method: Swift.String, callback: @escaping (ViewerExtension.ArgumentExtractor) throws -> Swift.Void)
  public func send(method: Swift.String, arguments: [Swift.Encodable], sendDidComplete: @escaping (Swift.Error?) -> Swift.Void)
  public func invoke(method: Swift.String, arguments: [Swift.Encodable], invocationDidComplete: @escaping (Swift.Error?) -> Swift.Void)
  public func invoke<T>(method: Swift.String, arguments: [Swift.Encodable], resultType: T.Type, invocationDidComplete: @escaping (T?, Swift.Error?) -> Swift.Void) where T : Swift.Decodable
  public func stream<T>(method: Swift.String, arguments: [Swift.Encodable], streamItemReceived: @escaping (T) -> Swift.Void, invocationDidComplete: @escaping (Swift.Error?) -> Swift.Void) -> ViewerExtension.StreamHandle where T : Swift.Decodable
  public func cancelStreamInvocation(streamHandle: ViewerExtension.StreamHandle, cancelDidFail: @escaping (Swift.Error) -> Swift.Void)
}
@_hasMissingDesignatedInitializers public class ArgumentExtractor {
  public func getArgument<T>(type: T.Type) throws -> T where T : Swift.Decodable
  public func hasMoreArgs() -> Swift.Bool
  @objc deinit
}
public protocol AVPlayerRemoteCommand {
  var reference: MediaPlayer.MPRemoteCommand { get }
  var isEnabled: (ViewerExtension.MediaType) -> Swift.Bool { get }
}
public enum ConnError : Swift.Error {
  case invalidURL
  case noData
  case noToken
  case unknown(Swift.String)
}
extension ConnError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public protocol NetworkDispatcher {
  var isReachable: Swift.Bool { get set }
  func dispatch(request: ViewerExtension.RequestData, onSuccess: @escaping (Foundation.Data) -> Swift.Void, onError: @escaping (Swift.Error) -> Swift.Void)
}
@_hasMissingDesignatedInitializers public class URLSessionNetworkDispatcher : ViewerExtension.NetworkDispatcher {
  public static let instance: ViewerExtension.URLSessionNetworkDispatcher
  public var isReachable: Swift.Bool
  public func dispatch(request: ViewerExtension.RequestData, onSuccess: @escaping (Foundation.Data) -> Swift.Void, onError: @escaping (Swift.Error) -> Swift.Void)
  @objc deinit
}
extension HubConnection {
  public func invoke(method: Swift.String, invocationDidComplete: @escaping (Swift.Error?) -> Swift.Void)
  public func invoke<T1>(method: Swift.String, _ arg1: T1, invocationDidComplete: @escaping (Swift.Error?) -> Swift.Void) where T1 : Swift.Encodable
  public func invoke<T1, T2>(method: Swift.String, _ arg1: T1, _ arg2: T2, invocationDidComplete: @escaping (Swift.Error?) -> Swift.Void) where T1 : Swift.Encodable, T2 : Swift.Encodable
  public func invoke<T1, T2, T3>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, invocationDidComplete: @escaping (Swift.Error?) -> Swift.Void) where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable
  public func invoke<T1, T2, T3, T4>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, _ arg4: T4, invocationDidComplete: @escaping (Swift.Error?) -> Swift.Void) where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable, T4 : Swift.Encodable
  public func invoke<T1, T2, T3, T4, T5>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, _ arg4: T4, _ arg5: T5, invocationDidComplete: @escaping (Swift.Error?) -> Swift.Void) where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable, T4 : Swift.Encodable, T5 : Swift.Encodable
  public func invoke<T1, T2, T3, T4, T5, T6>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, _ arg4: T4, _ arg5: T5, _ arg6: T6, invocationDidComplete: @escaping (Swift.Error?) -> Swift.Void) where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable, T4 : Swift.Encodable, T5 : Swift.Encodable, T6 : Swift.Encodable
  public func invoke<T1, T2, T3, T4, T5, T6, T7>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, _ arg4: T4, _ arg5: T5, _ arg6: T6, _ arg7: T7, invocationDidComplete: @escaping (Swift.Error?) -> Swift.Void) where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable, T4 : Swift.Encodable, T5 : Swift.Encodable, T6 : Swift.Encodable, T7 : Swift.Encodable
  public func invoke<T1, T2, T3, T4, T5, T6, T7, T8>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, _ arg4: T4, _ arg5: T5, _ arg6: T6, _ arg7: T7, _ arg8: T8, invocationDidComplete: @escaping (Swift.Error?) -> Swift.Void) where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable, T4 : Swift.Encodable, T5 : Swift.Encodable, T6 : Swift.Encodable, T7 : Swift.Encodable, T8 : Swift.Encodable
  public func invoke<TRes>(method: Swift.String, resultType: TRes.Type, invocationDidComplete: @escaping (TRes?, Swift.Error?) -> Swift.Void) where TRes : Swift.Decodable
  public func invoke<T1, TRes>(method: Swift.String, _ arg1: T1, resultType: TRes.Type, invocationDidComplete: @escaping (TRes?, Swift.Error?) -> Swift.Void) where T1 : Swift.Encodable, TRes : Swift.Decodable
  public func invoke<T1, T2, TRes>(method: Swift.String, _ arg1: T1, _ arg2: T2, resultType: TRes.Type, invocationDidComplete: @escaping (TRes?, Swift.Error?) -> Swift.Void) where T1 : Swift.Encodable, T2 : Swift.Encodable, TRes : Swift.Decodable
  public func invoke<T1, T2, T3, TRes>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, resultType: TRes.Type, invocationDidComplete: @escaping (TRes?, Swift.Error?) -> Swift.Void) where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable, TRes : Swift.Decodable
  public func invoke<T1, T2, T3, T4, TRes>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, _ arg4: T4, resultType: TRes.Type, invocationDidComplete: @escaping (TRes?, Swift.Error?) -> Swift.Void) where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable, T4 : Swift.Encodable, TRes : Swift.Decodable
  public func invoke<T1, T2, T3, T4, T5, TRes>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, _ arg4: T4, _ arg5: T5, resultType: TRes.Type, invocationDidComplete: @escaping (TRes?, Swift.Error?) -> Swift.Void) where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable, T4 : Swift.Encodable, T5 : Swift.Encodable, TRes : Swift.Decodable
  public func invoke<T1, T2, T3, T4, T5, T6, TRes>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, _ arg4: T4, _ arg5: T5, _ arg6: T6, resultType: TRes.Type, invocationDidComplete: @escaping (TRes?, Swift.Error?) -> Swift.Void) where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable, T4 : Swift.Encodable, T5 : Swift.Encodable, T6 : Swift.Encodable, TRes : Swift.Decodable
  public func invoke<T1, T2, T3, T4, T5, T6, T7, TRes>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, _ arg4: T4, _ arg5: T5, _ arg6: T6, _ arg7: T7, resultType: TRes.Type, invocationDidComplete: @escaping (TRes?, Swift.Error?) -> Swift.Void) where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable, T4 : Swift.Encodable, T5 : Swift.Encodable, T6 : Swift.Encodable, T7 : Swift.Encodable, TRes : Swift.Decodable
  public func invoke<T1, T2, T3, T4, T5, T6, T7, T8, TRes>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, _ arg4: T4, _ arg5: T5, _ arg6: T6, _ arg7: T7, _ arg8: T8, resultType: TRes.Type, invocationDidComplete: @escaping (TRes?, Swift.Error?) -> Swift.Void) where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable, T4 : Swift.Encodable, T5 : Swift.Encodable, T6 : Swift.Encodable, T7 : Swift.Encodable, T8 : Swift.Encodable, TRes : Swift.Decodable
  public func send(method: Swift.String, sendDidComplete: @escaping (Swift.Error?) -> Swift.Void = {_ in})
  public func send<T1>(method: Swift.String, _ arg1: T1, sendDidComplete: @escaping (Swift.Error?) -> Swift.Void = {_ in}) where T1 : Swift.Encodable
  public func send<T1, T2>(method: Swift.String, _ arg1: T1, _ arg2: T2, sendDidComplete: @escaping (Swift.Error?) -> Swift.Void = {_ in}) where T1 : Swift.Encodable, T2 : Swift.Encodable
  public func send<T1, T2, T3>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, sendDidComplete: @escaping (Swift.Error?) -> Swift.Void = {_ in}) where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable
  public func send<T1, T2, T3, T4>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, _ arg4: T4, sendDidComplete: @escaping (Swift.Error?) -> Swift.Void = {_ in}) where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable, T4 : Swift.Encodable
  public func send<T1, T2, T3, T4, T5>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, _ arg4: T4, _ arg5: T5, sendDidComplete: @escaping (Swift.Error?) -> Swift.Void = {_ in}) where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable, T4 : Swift.Encodable, T5 : Swift.Encodable
  public func send<T1, T2, T3, T4, T5, T6>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, _ arg4: T4, _ arg5: T5, _ arg6: T6, sendDidComplete: @escaping (Swift.Error?) -> Swift.Void = {_ in}) where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable, T4 : Swift.Encodable, T5 : Swift.Encodable, T6 : Swift.Encodable
  public func send<T1, T2, T3, T4, T5, T6, T7>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, _ arg4: T4, _ arg5: T5, _ arg6: T6, _ arg7: T7, sendDidComplete: @escaping (Swift.Error?) -> Swift.Void = {_ in}) where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable, T4 : Swift.Encodable, T5 : Swift.Encodable, T6 : Swift.Encodable, T7 : Swift.Encodable
  public func send<T1, T2, T3, T4, T5, T6, T7, T8>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, _ arg4: T4, _ arg5: T5, _ arg6: T6, _ arg7: T7, _ arg8: T8, sendDidComplete: @escaping (Swift.Error?) -> Swift.Void = {_ in}) where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable, T4 : Swift.Encodable, T5 : Swift.Encodable, T6 : Swift.Encodable, T7 : Swift.Encodable, T8 : Swift.Encodable
  public func on(method: Swift.String, callback: @escaping () -> Swift.Void)
  public func on<T1>(method: Swift.String, callback: @escaping (T1) -> Swift.Void) where T1 : Swift.Decodable
  public func on<T1, T2>(method: Swift.String, callback: @escaping (T1, T2) -> Swift.Void) where T1 : Swift.Decodable, T2 : Swift.Decodable
  public func on<T1, T2, T3>(method: Swift.String, callback: @escaping (T1, T2, T3) -> Swift.Void) where T1 : Swift.Decodable, T2 : Swift.Decodable, T3 : Swift.Decodable
  public func on<T1, T2, T3, T4>(method: Swift.String, callback: @escaping (T1, T2, T3, T4) -> Swift.Void) where T1 : Swift.Decodable, T2 : Swift.Decodable, T3 : Swift.Decodable, T4 : Swift.Decodable
  public func on<T1, T2, T3, T4, T5>(method: Swift.String, callback: @escaping (T1, T2, T3, T4, T5) -> Swift.Void) where T1 : Swift.Decodable, T2 : Swift.Decodable, T3 : Swift.Decodable, T4 : Swift.Decodable, T5 : Swift.Decodable
  public func on<T1, T2, T3, T4, T5, T6>(method: Swift.String, callback: @escaping (T1, T2, T3, T4, T5, T6) -> Swift.Void) where T1 : Swift.Decodable, T2 : Swift.Decodable, T3 : Swift.Decodable, T4 : Swift.Decodable, T5 : Swift.Decodable, T6 : Swift.Decodable
  public func on<T1, T2, T3, T4, T5, T6, T7>(method: Swift.String, callback: @escaping (T1, T2, T3, T4, T5, T6, T7) -> Swift.Void) where T1 : Swift.Decodable, T2 : Swift.Decodable, T3 : Swift.Decodable, T4 : Swift.Decodable, T5 : Swift.Decodable, T6 : Swift.Decodable, T7 : Swift.Decodable
  public func on<T1, T2, T3, T4, T5, T6, T7, T8>(method: Swift.String, callback: @escaping (T1, T2, T3, T4, T5, T6, T7, T8) -> Swift.Void) where T1 : Swift.Decodable, T2 : Swift.Decodable, T3 : Swift.Decodable, T4 : Swift.Decodable, T5 : Swift.Decodable, T6 : Swift.Decodable, T7 : Swift.Decodable, T8 : Swift.Decodable
  public func stream<TItemType>(method: Swift.String, streamItemReceived: @escaping (TItemType) -> Swift.Void, invocationDidComplete: @escaping (Swift.Error?) -> Swift.Void) -> ViewerExtension.StreamHandle where TItemType : Swift.Decodable
  public func stream<T1, TItemType>(method: Swift.String, _ arg1: T1, streamItemReceived: @escaping (TItemType) -> Swift.Void, invocationDidComplete: @escaping (Swift.Error?) -> Swift.Void) -> ViewerExtension.StreamHandle where T1 : Swift.Encodable, TItemType : Swift.Decodable
  public func stream<T1, T2, TItemType>(method: Swift.String, _ arg1: T1, _ arg2: T2, streamItemReceived: @escaping (TItemType) -> Swift.Void, invocationDidComplete: @escaping (Swift.Error?) -> Swift.Void) -> ViewerExtension.StreamHandle where T1 : Swift.Encodable, T2 : Swift.Encodable, TItemType : Swift.Decodable
  public func stream<T1, T2, T3, TItemType>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, streamItemReceived: @escaping (TItemType) -> Swift.Void, invocationDidComplete: @escaping (Swift.Error?) -> Swift.Void) -> ViewerExtension.StreamHandle where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable, TItemType : Swift.Decodable
  public func stream<T1, T2, T3, T4, TItemType>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, _ arg4: T4, streamItemReceived: @escaping (TItemType) -> Swift.Void, invocationDidComplete: @escaping (Swift.Error?) -> Swift.Void) -> ViewerExtension.StreamHandle where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable, T4 : Swift.Encodable, TItemType : Swift.Decodable
  public func stream<T1, T2, T3, T4, T5, TItemType>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, _ arg4: T4, _ arg5: T5, streamItemReceived: @escaping (TItemType) -> Swift.Void, invocationDidComplete: @escaping (Swift.Error?) -> Swift.Void) -> ViewerExtension.StreamHandle where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable, T4 : Swift.Encodable, T5 : Swift.Encodable, TItemType : Swift.Decodable
  public func stream<T1, T2, T3, T4, T5, T6, TItemType>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, _ arg4: T4, _ arg5: T5, _ arg6: T6, streamItemReceived: @escaping (TItemType) -> Swift.Void, invocationDidComplete: @escaping (Swift.Error?) -> Swift.Void) -> ViewerExtension.StreamHandle where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable, T4 : Swift.Encodable, T5 : Swift.Encodable, T6 : Swift.Encodable, TItemType : Swift.Decodable
  public func stream<T1, T2, T3, T4, T5, T6, T7, TItemType>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, _ arg4: T4, _ arg5: T5, _ arg6: T6, _ arg7: T7, streamItemReceived: @escaping (TItemType) -> Swift.Void, invocationDidComplete: @escaping (Swift.Error?) -> Swift.Void) -> ViewerExtension.StreamHandle where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable, T4 : Swift.Encodable, T5 : Swift.Encodable, T6 : Swift.Encodable, T7 : Swift.Encodable, TItemType : Swift.Decodable
  public func stream<T1, T2, T3, T4, T5, T6, T7, T8, TItemType>(method: Swift.String, _ arg1: T1, _ arg2: T2, _ arg3: T3, _ arg4: T4, _ arg5: T5, _ arg6: T6, _ arg7: T7, _ arg8: T8, streamItemReceived: @escaping (TItemType) -> Swift.Void, invocationDidComplete: @escaping (Swift.Error?) -> Swift.Void) -> ViewerExtension.StreamHandle where T1 : Swift.Encodable, T2 : Swift.Encodable, T3 : Swift.Encodable, T4 : Swift.Encodable, T5 : Swift.Encodable, T6 : Swift.Encodable, T7 : Swift.Encodable, T8 : Swift.Encodable, TItemType : Swift.Decodable
}
public class DataSource {
  public init()
  public var streams: [ViewerExtension.Live]
  public var videos: [ViewerExtension.VOD]
  public var newVod: ViewerExtension.VOD?
  public var firebaseFetcher: ViewerExtension.FirebaseFetcher?
  public func getViewers(for liveID: Swift.Int, complitionHandler: @escaping (Swift.Result<Swift.Int, Swift.Error>) -> Swift.Void)
  public func updateVods(complitionHandler: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func fetchNextItemsFrom(index: Swift.Int, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  @objc deinit
}
extension DataSource {
  public func pauseUpdatingStreams()
  public func pauseUpdatingVods()
  public func startUpdatingStreams()
  public func startUpdatingVods()
}
public struct SponsoredBanner : Swift.Codable {
  public let imageUrl: Swift.String
  public let externalUrl: Swift.String?
  public static var current: ViewerExtension.SponsoredBanner? {
    get
    set
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers public class StorageManager {
  public static var shared: ViewerExtension.StorageManager
  @objc deinit
}
extension StorageManager {
  public func loadVideoContent(content: ViewerExtension.VideoContent) -> ViewerExtension.VideoContentMO
  public func loadStoptime(for videoContent: ViewerExtension.VideoContent) -> Swift.String
  public func saveStoptime(for videoContent: ViewerExtension.VideoContent, value: Swift.String)
  public func saveLatestComment(for videoContent: ViewerExtension.VideoContent, value: ViewerExtension.LatestComment?)
  public func saveChat(for videoContent: ViewerExtension.VideoContent, value: [ViewerExtension.Message])
  public func savePolls(for videoContent: ViewerExtension.VideoContent, value: [ViewerExtension.Poll])
}
extension VideoContentMO {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<ViewerExtension.VideoContentMO>
  @objc @NSManaged dynamic public var date: Foundation.Date {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var id: Swift.Int64 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var latestMessage: ViewerExtension.LatestComment? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var stopTime: Swift.String {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var chatLoaded: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var latestCommentLoaded: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var messagesMO: Foundation.NSSet? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var pollsMO: Foundation.NSSet? {
    @objc get
    @objc set
  }
  public var messages: [ViewerExtension.Message]? {
    get
  }
}
extension VideoContentMO {
  @objc(addMessagesMOObject:) @NSManaged dynamic public func addToMessagesMO(_ value: ViewerExtension.MessageMO)
  @objc(removeMessagesMOObject:) @NSManaged dynamic public func removeFromMessagesMO(_ value: ViewerExtension.MessageMO)
  @objc(addMessagesMO:) @NSManaged dynamic public func addToMessagesMO(_ values: Foundation.NSSet)
  @objc(removeMessagesMO:) @NSManaged dynamic public func removeFromMessagesMO(_ values: Foundation.NSSet)
}
extension VideoContentMO {
  @objc(addPollsMOObject:) @NSManaged dynamic public func addToPollsMO(_ value: ViewerExtension.PollMO)
  @objc(removePollsMOObject:) @NSManaged dynamic public func removeFromPollsMO(_ value: ViewerExtension.PollMO)
  @objc(addPollsMO:) @NSManaged dynamic public func addToPollsMO(_ values: Foundation.NSSet)
  @objc(removePollsMO:) @NSManaged dynamic public func removeFromPollsMO(_ values: Foundation.NSSet)
}
public protocol VideoContent {
  var id: Swift.Int { get }
  var title: Swift.String { get }
  var url: Swift.String { get }
  var creatorName: Swift.String { get }
  var creatorNickname: Swift.String { get }
  var thumbnailUrl: Swift.String? { get }
  var date: Foundation.Date { get }
  var broadcasterPicUrl: Swift.String { get }
  var latestMessage: ViewerExtension.LatestComment? { get set }
  var isChatOn: Swift.Bool { get }
  var isPollOn: Swift.Bool { get }
  var shareLink: Swift.String? { get }
  var viewsCount: Swift.Int { get }
}
@_hasMissingDesignatedInitializers final public class Live : ViewerExtension.VideoContent, Swift.Codable {
  final public var id: Swift.Int
  final public var title: Swift.String
  final public var latestMessage: ViewerExtension.LatestComment?
  final public var isChatOn: Swift.Bool
  final public var isPollOn: Swift.Bool
  final public var shareLink: Swift.String?
  final public var creatorName: Swift.String
  final public var creatorNickname: Swift.String
  final public var thumbnailUrl: Swift.String?
  final public var url: Swift.String {
    get
  }
  final public var date: Foundation.Date
  final public var viewsCount: Swift.Int
  final public var broadcasterPicUrl: Swift.String
  @objc deinit
  public init(from decoder: Swift.Decoder) throws
  final public func encode(to encoder: Swift.Encoder) throws
}
final public class VOD : ViewerExtension.VideoContent {
  final public var isNew: Swift.Bool
  final public var viewsCount: Swift.Int
  final public var stopTime: Swift.String {
    get
    set
  }
  final public var id: Swift.Int
  final public var title: Swift.String
  final public var url: Swift.String
  final public var creatorName: Swift.String
  final public var creatorNickname: Swift.String
  final public var thumbnailUrl: Swift.String?
  final public var creatorId: Swift.Int
  final public var date: Foundation.Date
  final public var duration: Swift.String {
    get
  }
  final public var broadcasterPicUrl: Swift.String
  final public var watchedTime: Swift.Int?
  final public var latestMessage: ViewerExtension.LatestComment?
  final public var isChatOn: Swift.Bool
  final public var isPollOn: Swift.Bool
  final public var shareLink: Swift.String?
  final public var curtainRangeModels: [ViewerExtension.CurtainRange]
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
}
extension VOD : Swift.Codable {
  final public func encode(to encoder: Swift.Encoder) throws
}
public protocol FirebaseFetcher {
  func setLatestMessagesTo(VODs: [ViewerExtension.VOD], completion: @escaping (() -> ()))
  func setInfoTo(lives: [ViewerExtension.Live], completion: @escaping (() -> ()))
}
public enum ContentType : Swift.String, Swift.Codable {
  case VOD
  case live
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public struct Statistic {
  public enum Action {
    case open
    case close(span: Swift.Int)
  }
  public static func save(action: ViewerExtension.Statistic.Action, for contentType: ViewerExtension.ContentType, contentID: Swift.Int)
  public static func send(action: ViewerExtension.Statistic.Action, for contentType: ViewerExtension.ContentType, contentID: Swift.Int)
  public static func sync()
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class SeekPaddingView : UIKit.UIView {
  public var soughtTime: Swift.Int {
    get
    set
  }
  public init(showInView view: UIKit.UIView)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  public func seekBackward()
  @objc deinit
  public func seekForward()
}
extension PollMO {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<ViewerExtension.PollMO>
  @objc @NSManaged dynamic public var key: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var pollAnswers: [Foundation.NSNumber]? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var pollQuestion: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var userAnswer: Foundation.NSNumber? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var content: ViewerExtension.VideoContentMO? {
    @objc get
    @objc set
  }
}
@_inheritsConvenienceInitializers @objc(MessageMO) public class MessageMO : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension AVPlayer {
  public var isPlaying: Swift.Bool {
    get
  }
}
@_hasMissingDesignatedInitializers public class HttpResponse {
  @objc deinit
}
public class Debouncer {
  public init(delay: Foundation.TimeInterval, queue: Dispatch.DispatchQueue = DispatchQueue.main)
  public func call(delay: Foundation.TimeInterval? = nil, action: @escaping () -> Swift.Void)
  @objc deinit
}
public protocol PlayerConfiguration {
  var rateObservingTimeout: Foundation.TimeInterval { get }
  var rateObservingTickTime: Foundation.TimeInterval { get }
  var preferredTimescale: CoreMedia.CMTimeScale { get }
  var periodicPlayingTime: CoreMedia.CMTime { get }
  var audioSessionCategory: AVFoundation.AVAudioSession.Category { get }
  var reachabilityURLSessionTimeout: Foundation.TimeInterval { get }
  var reachabilityNetworkTestingURL: Foundation.URL { get }
  var reachabilityNetworkTestingTickTime: Foundation.TimeInterval { get }
  var reachabilityNetworkTestingIteration: Swift.UInt { get }
  var useDefaultRemoteCommand: Swift.Bool { get }
  var allowsExternalPlayback: Swift.Bool { get }
  var itemLoadedAssetKeys: [Swift.String] { get }
}
public enum LogLevel : Swift.Int {
  case error
  case warning
  case info
  case debug
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public protocol Logger {
  func log(logLevel: ViewerExtension.LogLevel, message: @autoclosure () -> Swift.String)
}
extension LogLevel {
  public func toString() -> Swift.String
}
public class PrintLogger : ViewerExtension.Logger {
  public init()
  public func log(logLevel: ViewerExtension.LogLevel, message: @autoclosure () -> Swift.String)
  @objc deinit
}
public class NullLogger : ViewerExtension.Logger {
  public init()
  public func log(logLevel: ViewerExtension.LogLevel, message: @autoclosure () -> Swift.String)
  @objc deinit
}
public protocol HubConnectionDelegate : AnyObject {
  func connectionDidOpen(hubConnection: ViewerExtension.HubConnection)
  func connectionDidFailToOpen(error: Swift.Error)
  func connectionDidClose(error: Swift.Error?)
  func connectionWillReconnect(error: Swift.Error)
  func connectionDidReconnect()
}
extension HubConnectionDelegate {
  public func connectionWillReconnect(error: Swift.Error)
  public func connectionDidReconnect()
}
public protocol HttpClientProtocol {
  func get(url: Foundation.URL, completionHandler: @escaping (ViewerExtension.HttpResponse?, Swift.Error?) -> Swift.Void)
  func post(url: Foundation.URL, body: Foundation.Data?, completionHandler: @escaping (ViewerExtension.HttpResponse?, Swift.Error?) -> Swift.Void)
  func delete(url: Foundation.URL, completionHandler: @escaping (ViewerExtension.HttpResponse?, Swift.Error?) -> Swift.Void)
}
public struct ModernAVPlayerMediaMetadata : ViewerExtension.PlayerMediaMetadata, Swift.Equatable {
  public let title: Swift.String?
  public let albumTitle: Swift.String?
  public let artist: Swift.String?
  public let image: Foundation.Data?
  public let remoteImageUrl: Foundation.URL?
  public init(title: Swift.String? = nil, albumTitle: Swift.String? = nil, artist: Swift.String? = nil, image: Foundation.Data? = nil, remoteImageUrl: Foundation.URL? = nil)
  public static func == (a: ViewerExtension.ModernAVPlayerMediaMetadata, b: ViewerExtension.ModernAVPlayerMediaMetadata) -> Swift.Bool
}
public struct ViewersCount : Swift.Codable {
  public let liveStreamId: Swift.Int
  public let viewers: Swift.Int
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public protocol Chat {
  var onAdd: ((ViewerExtension.Message) -> ())? { get set }
  var onRemove: ((ViewerExtension.Message) -> ())? { get set }
  var onStateChange: ((Swift.Bool) -> ())? { get set }
  func send(message: ViewerExtension.Message, withCompletionBlock: @escaping (Swift.Error?) -> ())
}
public typealias ModernAVPlayerExposable = ViewerExtension.MediaPlayer & ViewerExtension.ModernAVPlayerCurrentState
@_inheritsConvenienceInitializers @objc(PollMO) public class PollMO : CoreData.NSManagedObject {
  @objc deinit
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
}
public struct Message {
  public var key: Swift.String
  public let timestamp: Swift.Int
  public let userID: Swift.String
  public let nickname: Swift.String
  public let text: Swift.String
  public let avatarUrl: Swift.String?
  public init(userID: Swift.String, timestamp: Swift.Int = Int(Date().timeIntervalSince1970), nickname: Swift.String, text: Swift.String, key: Swift.String = "", avatarUrl: Swift.String? = nil)
  public init?(data: [Swift.String : Any], docID: Swift.String, date: Foundation.Date?)
}
@_hasMissingDesignatedInitializers public class LongPollingTransport : ViewerExtension.Transport {
  public var delegate: ViewerExtension.TransportDelegate?
  public func start(url: Foundation.URL, options: ViewerExtension.HttpConnectionOptions)
  public func send(data: Foundation.Data, sendDidComplete: @escaping (Swift.Error?) -> Swift.Void)
  public func close()
  @objc deinit
}
extension UIColor {
  public func as1ptImage() -> UIKit.UIImage
  public static func color(_ name: Swift.String) -> UIKit.UIColor?
  public static var darkTitle: UIKit.UIColor {
    get
  }
  public static var pink: UIKit.UIColor {
    get
  }
  public static var cellGray: UIKit.UIColor {
    get
  }
  public static var designerGreen: UIKit.UIColor {
    get
  }
  public static var designerBlue: UIKit.UIColor {
    get
  }
  public static var gradientDark: UIKit.UIColor {
    get
  }
  public static var bottomMessageGray: UIKit.UIColor {
    get
  }
  public static var curtainYellow: UIKit.UIColor {
    get
  }
}
public class HubConnectionBuilder {
  public init(url: Foundation.URL)
  public func withHubProtocol(hubProtocolFactory: @escaping (ViewerExtension.Logger) -> ViewerExtension.HubProtocol) -> ViewerExtension.HubConnectionBuilder
  public func withHttpConnectionOptions(configureHttpOptions: (ViewerExtension.HttpConnectionOptions) -> Swift.Void) -> ViewerExtension.HubConnectionBuilder
  public func withLogging(minLogLevel: ViewerExtension.LogLevel) -> ViewerExtension.HubConnectionBuilder
  public func withLogging(logger: ViewerExtension.Logger) -> ViewerExtension.HubConnectionBuilder
  public func withLogging(minLogLevel: ViewerExtension.LogLevel, logger: ViewerExtension.Logger) -> ViewerExtension.HubConnectionBuilder
  public func withHubConnectionDelegate(delegate: ViewerExtension.HubConnectionDelegate) -> ViewerExtension.HubConnectionBuilder
  public func withAutoReconnect(reconnectPolicy: ViewerExtension.ReconnectPolicy = DefaultReconnectPolicy()) -> ViewerExtension.HubConnectionBuilder
  public func withPermittedTransportTypes(_ permittedTransportTypes: ViewerExtension.TransportType) -> ViewerExtension.HubConnectionBuilder
  @available(*, deprecated)
  public func withLegacyHttpConnection() -> ViewerExtension.HubConnectionBuilder
  public func build() -> ViewerExtension.HubConnection
  @objc deinit
}
extension HubConnectionBuilder {
  public func withJSONHubProtocol() -> ViewerExtension.HubConnectionBuilder
}
public struct UploadImageResponse : Swift.Codable {
  public let success: Swift.Bool
  public let imageUrl: Swift.String?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public enum HTTPMethod : Swift.String {
  case get
  case post
  case put
  case delete
  case patch
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
}
public struct RequestData {
}
public protocol ConnectionDelegate : AnyObject {
  func connectionDidOpen(connection: ViewerExtension.Connection)
  func connectionDidFailToOpen(error: Swift.Error)
  func connectionDidReceiveData(connection: ViewerExtension.Connection, data: Foundation.Data)
  func connectionDidClose(error: Swift.Error?)
  func connectionWillReconnect(error: Swift.Error)
  func connectionDidReconnect()
}
extension ConnectionDelegate {
  public func connectionWillReconnect(error: Swift.Error)
  public func connectionDidReconnect()
}
public enum ReachabilityError : Swift.Error {
  case failedToCreateWithAddress(Darwin.sockaddr, Swift.Int32)
  case failedToCreateWithHostname(Swift.String, Swift.Int32)
  case unableToSetCallback(Swift.Int32)
  case unableToSetDispatchQueue(Swift.Int32)
  case unableToGetFlags(Swift.Int32)
}
@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
public let ReachabilityChangedNotification: Foundation.NSNotification.Name
extension NSNotification.Name {
  public static let reachabilityChanged: Foundation.Notification.Name
}
public class Reachability {
  public typealias NetworkReachable = (ViewerExtension.Reachability) -> ()
  public typealias NetworkUnreachable = (ViewerExtension.Reachability) -> ()
  @available(*, unavailable, renamed: "Connection")
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable, reachableViaWiFi, reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: ViewerExtension.Reachability.NetworkStatus, b: ViewerExtension.Reachability.NetworkStatus) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum Connection : Swift.CustomStringConvertible {
    case unavailable, wifi, cellular
    public var description: Swift.String {
      get
    }
    @available(*, deprecated, renamed: "unavailable")
    public static let none: ViewerExtension.Reachability.Connection
    public static func == (a: ViewerExtension.Reachability.Connection, b: ViewerExtension.Reachability.Connection) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public var whenReachable: ViewerExtension.Reachability.NetworkReachable?
  public var whenUnreachable: ViewerExtension.Reachability.NetworkUnreachable?
  @available(*, deprecated, renamed: "allowsCellularConnection")
  final public let reachableOnWWAN: Swift.Bool
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  @available(*, deprecated, renamed: "connection.description")
  public var currentReachabilityString: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "connection")
  public var currentReachabilityStatus: ViewerExtension.Reachability.Connection {
    get
  }
  public var connection: ViewerExtension.Reachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main)
  convenience public init(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  convenience public init(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  @objc deinit
}
extension Reachability {
  public func startNotifier() throws
  public func stopNotifier()
  @available(*, deprecated, message: "Please use `connection != .none`")
  public var isReachable: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .cellular`")
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .wifi`")
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
public protocol ModernAVPlayerDelegate : AnyObject {
  func modernAVPlayer(_ player: ViewerExtension.ModernAVPlayer, didStateChange state: ViewerExtension.ModernAVPlayer.State)
  func modernAVPlayer(_ player: ViewerExtension.ModernAVPlayer, didCurrentMediaChange media: ViewerExtension.PlayerMedia?)
  func modernAVPlayer(_ player: ViewerExtension.ModernAVPlayer, didCurrentTimeChange currentTime: Swift.Double)
  func modernAVPlayer(_ player: ViewerExtension.ModernAVPlayer, didItemDurationChange itemDuration: Swift.Double?)
  func modernAVPlayer(_ player: ViewerExtension.ModernAVPlayer, unavailableActionReason: ViewerExtension.PlayerUnavailableActionReason)
  func modernAVPlayer(_ player: ViewerExtension.ModernAVPlayer, didItemPlayToEndTime endTime: Swift.Double)
}
extension ModernAVPlayerDelegate {
  public func modernAVPlayer(_ player: ViewerExtension.ModernAVPlayer, didStateChange state: ViewerExtension.ModernAVPlayer.State)
  public func modernAVPlayer(_ player: ViewerExtension.ModernAVPlayer, didCurrentMediaChange media: ViewerExtension.PlayerMedia?)
  public func modernAVPlayer(_ player: ViewerExtension.ModernAVPlayer, didCurrentTimeChange currentTime: Swift.Double)
  public func modernAVPlayer(_ player: ViewerExtension.ModernAVPlayer, didItemDurationChange itemDuration: Swift.Double?)
  public func modernAVPlayer(_ player: ViewerExtension.ModernAVPlayer, unavailableActionReason: ViewerExtension.PlayerUnavailableActionReason)
  public func modernAVPlayer(_ player: ViewerExtension.ModernAVPlayer, didItemPlayToEndTime endTime: Swift.Double)
}
public protocol TransportDelegate : AnyObject {
  func transportDidOpen()
  func transportDidReceiveData(_ data: Foundation.Data)
  func transportDidClose(_ error: Swift.Error?)
}
public struct CurtainRange : Swift.Codable {
  public init(start: Swift.String, end: Swift.String)
  public init(from decoder: Swift.Decoder) throws
  public mutating func setAccuracy(to newAccuracy: Swift.Double)
  public var range: Swift.ClosedRange<Swift.Double> {
    mutating get
    set
  }
  public func encode(to encoder: Swift.Encoder) throws
}
public protocol Poll {
  var key: Swift.String { get set }
  var userAnswer: Swift.Int? { get set }
  var pollQuestion: Swift.String { get set }
  var pollAnswers: [Swift.String] { get set }
  var answersCount: [Swift.Int] { get set }
  var onUpdate: (() -> ())? { get set }
  var percentForEachAnswer: [Swift.Int] { get set }
  func saveAnswerWith(index: Swift.Int)
}
public struct Environment {
  public enum EnvironmentType : Swift.String {
    case prod
    case staging
    case dev
    case load
    case demo
    public var host: Swift.String {
      get
    }
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
  }
  public static var current: ViewerExtension.Environment.EnvironmentType {
    get
  }
  public static func set(environment: ViewerExtension.Environment.EnvironmentType)
}
@objc @_inheritsConvenienceInitializers open class IQTextView : UIKit.UITextView {
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic public init(frame: CoreGraphics.CGRect, textContainer: UIKit.NSTextContainer?)
  @objc override dynamic open func awakeFromNib()
  @objc deinit
  @objc @IBInspectable open var placeholderTextColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable open var placeholder: Swift.String? {
    @objc get
    @objc set
  }
  open var attributedPlaceholder: Foundation.NSAttributedString? {
    get
    set
  }
  @objc override dynamic open func layoutSubviews()
  @objc override dynamic open var text: Swift.String! {
    @objc get
    @objc set
  }
  @objc override dynamic open var attributedText: Foundation.NSAttributedString! {
    @objc get
    @objc set
  }
  @objc override dynamic open var font: UIKit.UIFont? {
    @objc get
    @objc set
  }
  @objc override dynamic open var textAlignment: UIKit.NSTextAlignment {
    @objc get
    @objc set
  }
  @objc override dynamic open var delegate: UIKit.UITextViewDelegate? {
    @objc get
    @objc set
  }
  @objc override dynamic open var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
}
public enum TransferFormat : Swift.String {
  case text
  case binary
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public enum MediaType {
  case clip
  case stream(isLive: Swift.Bool)
}
extension MediaType : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension MediaType : Swift.Equatable {
}
public func == (lhs: ViewerExtension.MediaType, rhs: ViewerExtension.MediaType) -> Swift.Bool
public struct ModernAVPlayerRemoteCommand : ViewerExtension.AVPlayerRemoteCommand, Swift.CustomDebugStringConvertible {
  public let reference: MediaPlayer.MPRemoteCommand
  public let isEnabled: (ViewerExtension.MediaType) -> Swift.Bool
  public let debugDescription: Swift.String
  public init(reference: MediaPlayer.MPRemoteCommand, debugDescription: Swift.String? = nil, isEnabled: @escaping (ViewerExtension.MediaType) -> Swift.Bool)
}
public protocol MediaPlayer : AnyObject, ViewerExtension.PlayerCommand {
  var currentMedia: ViewerExtension.PlayerMedia? { get }
  var currentTime: Swift.Double { get }
  var loopMode: Swift.Bool { get set }
  var player: AVFoundation.AVPlayer { get }
  var remoteCommands: [ViewerExtension.ModernAVPlayerRemoteCommand]? { get }
  func updateMetadata(_ metadata: ViewerExtension.PlayerMediaMetadata?)
}
public enum SignalRError : Swift.Error {
  case invalidState
  case webError(statusCode: Swift.Int)
  case hubInvocationError(message: Swift.String)
  case hubInvocationCancelled
  case unknownMessageType
  case invalidMessage
  case unsupportedType
  case serializationError(underlyingError: Swift.Error)
  case connectionIsBeingClosed
  case invalidOperation(message: Swift.String)
  case protocolViolation(underlyingError: Swift.Error)
  case handshakeError(message: Swift.String)
  case invalidNegotiationResponse(message: Swift.String)
  case serverClose(message: Swift.String?)
  case noSupportedTransportAvailable
  case connectionIsReconnecting
}
public enum ModernAVPlayerLoggerDomain : Swift.CustomStringConvertible {
  case state
  case service
  case error
  case lifecycleService
  case lifecycleState
  case remoteCommand
  case unavailableCommand
  public var description: Swift.String {
    get
  }
  public static func == (a: ViewerExtension.ModernAVPlayerLoggerDomain, b: ViewerExtension.ModernAVPlayerLoggerDomain) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@objc final public class ModernAVPlayer : ObjectiveC.NSObject, ViewerExtension.ModernAVPlayerExposable {
  weak final public var delegate: ViewerExtension.ModernAVPlayerDelegate?
  final public var player: AVFoundation.AVPlayer {
    get
  }
  final public var state: ViewerExtension.ModernAVPlayer.State {
    get
  }
  final public var currentMedia: ViewerExtension.PlayerMedia? {
    get
  }
  final public var currentTime: Swift.Double {
    get
  }
  final public var loopMode: Swift.Bool {
    get
    set
  }
  final public var remoteCommands: [ViewerExtension.ModernAVPlayerRemoteCommand]? {
    get
    set
  }
  public init(player: AVFoundation.AVPlayer = AVPlayer(), config: ViewerExtension.PlayerConfiguration = ModernAVPlayerConfiguration(), plugins: [ViewerExtension.PlayerPlugin] = [], loggerDomains: [ViewerExtension.ModernAVPlayerLoggerDomain] = [])
  final public func pause()
  final public func seek(position: Swift.Double)
  final public func seek(offset: Swift.Double)
  final public func stop()
  final public func load(media: ViewerExtension.PlayerMedia, autostart: Swift.Bool, position: Swift.Double? = nil)
  final public func updateMetadata(_ metadata: ViewerExtension.PlayerMediaMetadata?)
  final public func play()
  @objc override dynamic public init()
  @objc deinit
}
extension ModernAVPlayer {
  public enum State : Swift.String, Swift.CustomStringConvertible {
    case buffering
    case failed
    case initialization
    case loaded
    case loading
    case paused
    case playing
    case stopped
    case waitingForNetwork
    public var description: Swift.String {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
}
public protocol FirebaseCreator {
  func createPollManagerFor(streamId: Swift.Int) -> ViewerExtension.PollManager
  func createChatFor(videoContent: ViewerExtension.VideoContent) -> ViewerExtension.Chat
  func createMessageFetcher() -> ViewerExtension.FirebaseFetcher
}
extension UIView {
  public func findViewController() -> UIKit.UIViewController?
  public func showActivityIndicator()
  public func removeActivityIndicator()
  public var isActivityIndicatorLoaded: Swift.Bool {
    get
  }
  public func fixInView(_ container: UIKit.UIView!)
  public func fadeIn(duration: Foundation.TimeInterval = 0.3, delay: Foundation.TimeInterval = 0.0, completion: @escaping ((Swift.Bool) -> Swift.Void) = {(finished: Bool) -> Void in })
  public func fadeOut(duration: Foundation.TimeInterval = 0.3, delay: Foundation.TimeInterval = 0.0, completion: @escaping (Swift.Bool) -> Swift.Void = {(finished: Bool) -> Void in })
  public func addBadge(title: Swift.String, corner: UIKit.UIRectCorner = .topRight, belowView: UIKit.UIView? = nil)
  public func hideBadge()
}
extension UIButton {
  @objc @IBInspectable dynamic public var imageFromBundle: Swift.String {
    @objc get
    @objc set
  }
}
extension UIImageView {
  @objc @IBInspectable dynamic public var imageFromBundle: Swift.String {
    @objc get
    @objc set
  }
}
extension UIImage {
  public static func image(_ name: Swift.String) -> UIKit.UIImage?
}
extension UIView {
  public func badge(text badgeText: Swift.String?, badgeEdgeInsets: UIKit.UIEdgeInsets? = nil, appearance: ViewerExtension.BadgeAppearance = BadgeAppearance())
}
extension UIBarButtonItem {
  @objc dynamic public func badge(text: Swift.String?)
  public func badge(text badgeText: Swift.String?, appearance: ViewerExtension.BadgeAppearance = BadgeAppearance())
}
public struct BadgeAppearance {
  public var font: UIKit.UIFont
  public var textAlignment: UIKit.NSTextAlignment
  public var borderColor: UIKit.UIColor
  public var borderWidth: CoreGraphics.CGFloat
  public var allowShadow: Swift.Bool
  public var backgroundColor: UIKit.UIColor
  public var textColor: UIKit.UIColor
  public var animate: Swift.Bool
  public var duration: Swift.Double
  public var distanceFromCenterY: CoreGraphics.CGFloat
  public var distanceFromCenterX: CoreGraphics.CGFloat
  public var size: CoreGraphics.CGSize?
  public init()
}
public struct TransportType : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public static let longPolling: ViewerExtension.TransportType
  public static let webSockets: ViewerExtension.TransportType
  public static let all: ViewerExtension.TransportType
  public typealias Element = ViewerExtension.TransportType
  public typealias ArrayLiteralElement = ViewerExtension.TransportType
  public typealias RawValue = Swift.Int
}
public protocol Connection {
  var delegate: ViewerExtension.ConnectionDelegate? { get set }
  var connectionId: Swift.String? { get }
  func start()
  func send(data: Foundation.Data, sendDidComplete: @escaping (Swift.Error?) -> Swift.Void)
  func stop(stopError: Swift.Error?)
}
public protocol PollManager {
  func observePolls(completion: @escaping ((ViewerExtension.Poll?) -> ()))
  func removeFirebaseObserver()
}
@objc @_inheritsConvenienceInitializers public class PollTableViewCell : UIKit.UITableViewCell {
  @objc @IBOutlet public var titleLabel: UIKit.UILabel!
  public var isStatistic: Swift.Bool {
    get
    set
  }
  public var isUserChoise: Swift.Bool {
    get
    set
  }
  public var percentage: Swift.Int {
    get
    set
  }
  @objc override dynamic public func awakeFromNib()
  @objc deinit
  @available(iOS 3.0, *)
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension UIImage : Foundation.NSDiscardableContent {
  @objc dynamic public func beginContentAccess() -> Swift.Bool
  @objc dynamic public func endContentAccess()
  @objc dynamic public func discardContentIfPossible()
  @objc dynamic public func isContentDiscarded() -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers public class FooterView : UIKit.UICollectionReusableView {
  @objc override dynamic public func awakeFromNib()
  @objc override dynamic public func layoutSubviews()
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public protocol ModernAVPlayerCurrentState : AnyObject {
  var state: ViewerExtension.ModernAVPlayer.State { get }
}
public class HttpConnectionOptions {
  public var headers: [Swift.String : Swift.String]
  public var accessTokenProvider: () -> Swift.String?
  public var httpClientFactory: (ViewerExtension.HttpConnectionOptions) -> ViewerExtension.HttpClientProtocol
  public var skipNegotiation: Swift.Bool
  public var requestTimeout: Swift.Double
  public init()
  @objc deinit
}
public struct User : Swift.Codable {
  public let id: Swift.Int
  public var displayName: Swift.String
  public var imageUrl: Swift.String?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension User {
  public static var current: ViewerExtension.User? {
    get
    set
  }
}
public struct HeaderInfoModel : Swift.Codable {
  public let imageUrl: Swift.String?
  public let tagLine: Swift.String?
  public var imageData: Foundation.Data?
  public static var currentInfo: ViewerExtension.HeaderInfoModel? {
    get
    set
  }
  public static func fetchInfo(completion: @escaping ((ViewerExtension.HeaderInfoModel?) -> ()))
  public init(imageUrl: Swift.String?, tagLine: Swift.String?, imageData: Foundation.Data?)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Formatter {
  public static let iso8601: Foundation.ISO8601DateFormatter
}
extension JSONDecoder.DateDecodingStrategy {
  public static let customISO8601: Foundation.JSONDecoder.DateDecodingStrategy
}
public enum ProtocolType : Swift.Int {
  case Text
  case Binary
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public protocol HubProtocol {
  var name: Swift.String { get }
  var version: Swift.Int { get }
  var type: ViewerExtension.ProtocolType { get }
  func parseMessages(input: Foundation.Data) throws -> [ViewerExtension.HubMessage]
  func writeMessage(message: ViewerExtension.HubMessage) throws -> Foundation.Data
}
public enum MessageType : Swift.Int, Swift.Codable {
  case Invocation
  case StreamItem
  case Completion
  case StreamInvocation
  case CancelInvocation
  case Ping
  case Close
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
  public init?(rawValue: Swift.Int)
}
public protocol HubMessage {
  var type: ViewerExtension.MessageType { get }
}
@_hasMissingDesignatedInitializers public class ServerInvocationMessage : ViewerExtension.HubMessage, Swift.Encodable {
  final public let type: ViewerExtension.MessageType
  final public let invocationId: Swift.String?
  final public let target: Swift.String
  final public let arguments: [Swift.Encodable]
  public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
public class ClientInvocationMessage : ViewerExtension.HubMessage, Swift.Decodable {
  final public let type: ViewerExtension.MessageType
  final public let target: Swift.String
  required public init(from decoder: Swift.Decoder) throws
  public func getArgument<T>(type: T.Type) throws -> T where T : Swift.Decodable
  @objc deinit
}
public class StreamItemMessage : ViewerExtension.HubMessage, Swift.Decodable {
  final public let type: ViewerExtension.MessageType
  final public let invocationId: Swift.String
  required public init(from decoder: Swift.Decoder) throws
  public func getItem<T>(_ type: T.Type) throws -> T where T : Swift.Decodable
  @objc deinit
}
public class CompletionMessage : ViewerExtension.HubMessage, Swift.Decodable {
  final public let type: ViewerExtension.MessageType
  final public let invocationId: Swift.String
  final public let error: Swift.String?
  final public let hasResult: Swift.Bool
  required public init(from decoder: Swift.Decoder) throws
  public func getResult<T>(_ type: T.Type) throws -> T? where T : Swift.Decodable
  @objc deinit
}
@_hasMissingDesignatedInitializers public class StreamInvocationMessage : ViewerExtension.HubMessage, Swift.Encodable {
  final public let type: ViewerExtension.MessageType
  final public let invocationId: Swift.String
  final public let target: Swift.String
  final public let arguments: [Swift.Encodable]
  public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
@_hasMissingDesignatedInitializers public class CancelInvocationMessage : ViewerExtension.HubMessage, Swift.Encodable {
  final public let type: ViewerExtension.MessageType
  final public let invocationId: Swift.String
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers public class PingMessage : ViewerExtension.HubMessage {
  final public let type: ViewerExtension.MessageType
  @objc deinit
}
@_hasMissingDesignatedInitializers public class CloseMessage : ViewerExtension.HubMessage, Swift.Decodable {
  public var type: ViewerExtension.MessageType {
    get
  }
  final public let error: Swift.String?
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers public class HttpConnection : ViewerExtension.Connection {
  weak public var delegate: ViewerExtension.ConnectionDelegate?
  public var connectionId: Swift.String? {
    get
  }
  convenience public init(url: Foundation.URL, options: ViewerExtension.HttpConnectionOptions = HttpConnectionOptions(), logger: ViewerExtension.Logger = NullLogger())
  @objc deinit
  public func start()
  public func send(data: Foundation.Data, sendDidComplete: @escaping (Swift.Error?) -> Swift.Void)
  public func stop(stopError: Swift.Error? = nil)
}
@_hasMissingDesignatedInitializers public class ConnectionTransportDelegate : ViewerExtension.TransportDelegate {
  public func transportDidOpen()
  public func transportDidReceiveData(_ data: Foundation.Data)
  public func transportDidClose(_ error: Swift.Error?)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(VideoContentMO) public class VideoContentMO : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
public enum WidgetLocale : Swift.String {
  case english
  case swedish
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public enum WidgetPosition : Swift.String {
  case topLeft, midLeft, bottomLeft
  case topMid, bottomMid
  case topRight, midRight, bottomRight
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public struct WidgetMargins {
  public let vertical: CoreGraphics.CGFloat
  public let horizontal: CoreGraphics.CGFloat
  public init(vertical: CoreGraphics.CGFloat, horizontal: CoreGraphics.CGFloat)
}
@_hasMissingDesignatedInitializers public class AntWidget {
  public static let shared: ViewerExtension.AntWidget
  public var firebaseCreator: ViewerExtension.FirebaseCreator?
  public var widgetView: ViewerExtension.WidgetView {
    get
    set
  }
  public var widgetLocale: ViewerExtension.WidgetLocale?
  public var widgetPosition: ViewerExtension.WidgetPosition {
    get
    set
  }
  public var widgetMargins: ViewerExtension.WidgetMargins {
    get
    set
  }
  public var onViewerAppear: ((Foundation.NSDictionary) -> Swift.Void)?
  public var onViewerDisappear: ((Foundation.NSDictionary) -> Swift.Void)?
  @objc deinit
  public static func authWith(apiKey: Swift.String, refUserId: Swift.String?, nickname: Swift.String?)
  public static func registerNotifications(FCMToken: Swift.String, completionHandler: @escaping (Swift.Result<Swift.String, Swift.Error>) -> Swift.Void)
  public static func objc_registerNotifications(FCMToken: Swift.String, completionHandler: @escaping (Swift.String?, Swift.Error?) -> Swift.Void)
  public func showFeed()
}
extension AntWidget : ViewerExtension.ModernAVPlayerDelegate {
  public func modernAVPlayer(_ player: ViewerExtension.ModernAVPlayer, didStateChange state: ViewerExtension.ModernAVPlayer.State)
  public func modernAVPlayer(_ player: ViewerExtension.ModernAVPlayer, didItemDurationChange itemDuration: Swift.Double?)
}
public enum PlayerUnavailableActionReason {
  case alreadyPaused
  case alreadyPlaying
  case alreadyStopped
  case alreadyTryingToPlay
  case seekPositionNotAvailable
  case loadMediaFirst
  case seekOverstepPosition
  case waitEstablishedNetwork
  case waitLoadedMedia
  public static func == (a: ViewerExtension.PlayerUnavailableActionReason, b: ViewerExtension.PlayerUnavailableActionReason) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct BooleanResponse : Swift.Codable {
  public let success: Swift.Bool
  public let error: Swift.String?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public protocol PlayerPlugin {
  func didInit(player: AVFoundation.AVPlayer)
  func willStartLoading(media: ViewerExtension.PlayerMedia)
  func didStartLoading(media: ViewerExtension.PlayerMedia)
  func didStartBuffering(media: ViewerExtension.PlayerMedia)
  func didLoad(media: ViewerExtension.PlayerMedia, duration: Swift.Double?)
  func didMediaChanged(_ media: ViewerExtension.PlayerMedia, previousMedia: ViewerExtension.PlayerMedia?)
  func willStartPlaying(media: ViewerExtension.PlayerMedia, position: Swift.Double)
  func didStartPlaying(media: ViewerExtension.PlayerMedia)
  func didPaused(media: ViewerExtension.PlayerMedia?, position: Swift.Double)
  func didStopped(media: ViewerExtension.PlayerMedia?, position: Swift.Double)
  func didStartWaitingForNetwork(media: ViewerExtension.PlayerMedia)
  func didFailed(media: ViewerExtension.PlayerMedia, error: ViewerExtension.PlayerError)
  func didItemPlayToEndTime(media: ViewerExtension.PlayerMedia, endTime: Swift.Double)
}
extension PlayerPlugin {
  public func didInit(player: AVFoundation.AVPlayer)
  public func willStartLoading(media: ViewerExtension.PlayerMedia)
  public func didStartLoading(media: ViewerExtension.PlayerMedia)
  public func didStartBuffering(media: ViewerExtension.PlayerMedia)
  public func didLoad(media: ViewerExtension.PlayerMedia, duration: Swift.Double?)
  public func didMediaChanged(_ media: ViewerExtension.PlayerMedia, previousMedia: ViewerExtension.PlayerMedia?)
  public func willStartPlaying(media: ViewerExtension.PlayerMedia, position: Swift.Double)
  public func didStartPlaying(media: ViewerExtension.PlayerMedia)
  public func didPaused(media: ViewerExtension.PlayerMedia?, position: Swift.Double)
  public func didStopped(media: ViewerExtension.PlayerMedia?, position: Swift.Double)
  public func didStartWaitingForNetwork(media: ViewerExtension.PlayerMedia)
  public func didFailed(media: ViewerExtension.PlayerMedia, error: ViewerExtension.PlayerError)
  public func didItemPlayToEndTime(media: ViewerExtension.PlayerMedia, endTime: Swift.Double)
}
public class JSONHubProtocol : ViewerExtension.HubProtocol {
  final public let name: Swift.String
  final public let version: Swift.Int
  final public let type: ViewerExtension.ProtocolType
  public init(logger: ViewerExtension.Logger, encoder: Foundation.JSONEncoder = JSONEncoder(), decoder: Foundation.JSONDecoder = JSONDecoder())
  public func parseMessages(input: Foundation.Data) throws -> [ViewerExtension.HubMessage]
  public func createHubMessage(payload: Foundation.Data) throws -> ViewerExtension.HubMessage
  public func writeMessage(message: ViewerExtension.HubMessage) throws -> Foundation.Data
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class EmptyDataSourceView : UIKit.UIView {
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
extension ViewerExtension.PlayerError : Swift.Equatable {}
extension ViewerExtension.PlayerError : Swift.Hashable {}
extension ViewerExtension.WebSocketBinaryType : Swift.Equatable {}
extension ViewerExtension.WebSocketBinaryType : Swift.Hashable {}
extension ViewerExtension.WebSocketReadyState : Swift.Equatable {}
extension ViewerExtension.WebSocketReadyState : Swift.Hashable {}
extension ViewerExtension.WebSocketReadyState : Swift.RawRepresentable {}
extension ViewerExtension.ContentType : Swift.Equatable {}
extension ViewerExtension.ContentType : Swift.Hashable {}
extension ViewerExtension.ContentType : Swift.RawRepresentable {}
extension ViewerExtension.LogLevel : Swift.Equatable {}
extension ViewerExtension.LogLevel : Swift.Hashable {}
extension ViewerExtension.LogLevel : Swift.RawRepresentable {}
extension ViewerExtension.HTTPMethod : Swift.Equatable {}
extension ViewerExtension.HTTPMethod : Swift.Hashable {}
extension ViewerExtension.HTTPMethod : Swift.RawRepresentable {}
@available(*, unavailable, renamed: "Connection")
extension ViewerExtension.Reachability.NetworkStatus : Swift.Equatable {}
@available(*, unavailable, renamed: "Connection")
extension ViewerExtension.Reachability.NetworkStatus : Swift.Hashable {}
extension ViewerExtension.Reachability.Connection : Swift.Equatable {}
extension ViewerExtension.Reachability.Connection : Swift.Hashable {}
extension ViewerExtension.Environment.EnvironmentType : Swift.Equatable {}
extension ViewerExtension.Environment.EnvironmentType : Swift.Hashable {}
extension ViewerExtension.Environment.EnvironmentType : Swift.RawRepresentable {}
extension ViewerExtension.TransferFormat : Swift.Equatable {}
extension ViewerExtension.TransferFormat : Swift.Hashable {}
extension ViewerExtension.TransferFormat : Swift.RawRepresentable {}
extension ViewerExtension.ModernAVPlayerLoggerDomain : Swift.Equatable {}
extension ViewerExtension.ModernAVPlayerLoggerDomain : Swift.Hashable {}
extension ViewerExtension.ModernAVPlayer.State : Swift.Equatable {}
extension ViewerExtension.ModernAVPlayer.State : Swift.Hashable {}
extension ViewerExtension.ModernAVPlayer.State : Swift.RawRepresentable {}
extension ViewerExtension.ProtocolType : Swift.Equatable {}
extension ViewerExtension.ProtocolType : Swift.Hashable {}
extension ViewerExtension.ProtocolType : Swift.RawRepresentable {}
extension ViewerExtension.MessageType : Swift.Equatable {}
extension ViewerExtension.MessageType : Swift.Hashable {}
extension ViewerExtension.MessageType : Swift.RawRepresentable {}
extension ViewerExtension.WidgetLocale : Swift.Equatable {}
extension ViewerExtension.WidgetLocale : Swift.Hashable {}
extension ViewerExtension.WidgetLocale : Swift.RawRepresentable {}
extension ViewerExtension.WidgetPosition : Swift.Equatable {}
extension ViewerExtension.WidgetPosition : Swift.Hashable {}
extension ViewerExtension.WidgetPosition : Swift.RawRepresentable {}
extension ViewerExtension.PlayerUnavailableActionReason : Swift.Equatable {}
extension ViewerExtension.PlayerUnavailableActionReason : Swift.Hashable {}
